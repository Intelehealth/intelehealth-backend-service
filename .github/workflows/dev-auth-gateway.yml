name: auth-gateway-production

# -----------------------------------------------------
# 1. SECURITY: Restrict GITHUB_TOKEN permissions
# -----------------------------------------------------
permissions:
  contents: read # Allow checkout
  packages: write # Allow pushing to GitHub Container Registry (ghcr.io) or other registry if needed

on:
  push:
    # 2. RELIABILITY: Use a dedicated 'main' or 'production' branch for production-level deployments
    branches: [development_master]
    paths:
      - 'auth-gateway/**'

env:
  DOCKER_IMAGE_NAME: auth-gateway
  # Standardize the registry to use GitHub's own for simplicity (ghcr.io)
  GH_REPO_OWNER_LOWER: ${{ github.repository_owner_lowercase }} # Standard GitHub environment variable
  REGISTRY: ghcr.io/${{ github.repository_owner }}
  
  # Remote Host variables remain, but deployment uses a dedicated action
  REMOTE_HOST: ${{secrets.DEV_HOST}}
  REMOTE_USER: ${{secrets.DEV_USER}}
  REMOTE_PORT: 22
  ENV_FILE_PATH: /home/ubuntu/deploy/auth-gateway/.env
  PEM_FOLDER_PATH: /home/ubuntu/deploy/auth-gateway/.pem

jobs:
  # -----------------------------------------------------
  # Job 1: Build, Scan, and Push the Docker Image
  # -----------------------------------------------------
  build:
    runs-on: ubuntu-latest
    outputs:
      image_tag: ${{ steps.image_meta.outputs.full_image_name }} # Pass the full tag to the deploy job
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    - name: Define Lowercase Repository Owner
      id: owner_lower
      run: |
        REPO_OWNER_LOWER=$(echo "${{ github.repository_owner }}" | tr '[:upper:]' '[:lower:]')
        echo "value=$REPO_OWNER_LOWER" >> $GITHUB_OUTPUT 
    # -----------------------------------------------------
    # EFFICIENCY: Login to the container registry
    # Use GITHUB_TOKEN to push to GitHub Container Registry (ghcr.io)
    # -----------------------------------------------------
    - name: Log in to GitHub Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.repository_owner }}
        password: ${{ secrets.GITHUB_TOKEN }}
        
    - name: Define Image Metadata
      id: image_meta
      run: |
        TAG_SHA="ghcr.io/${{ steps.owner_lower.outputs.value }}/${{ env.DOCKER_IMAGE_NAME }}:${{ github.sha }}"
        
        # This is the tag we will use for the deployment
        echo "full_image_name=$TAG_SHA" >> $GITHUB_OUTPUT 
        REPO_OWNER_LOWER=$(echo "${{ github.repository_owner }}" | tr '[:upper:]' '[:lower:]')
        FULL_IMAGE_NAME="ghcr.io/$REPO_OWNER_LOWER/${{ env.DOCKER_IMAGE_NAME }}:$TAG"

        #FULL_IMAGE_NAME=${{ env.REGISTRY }}/${{ env.DOCKER_IMAGE_NAME }}:$TAG
        echo "tag=$TAG" >> $GITHUB_OUTPUT
        echo "full_image_name=$FULL_IMAGE_NAME" >> $GITHUB_OUTPUT
        
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    # -----------------------------------------------------
    # EFFICIENCY: Use dedicated build-push action for caching and push
    # -----------------------------------------------------
    - name: Build and push Docker image
      uses: docker/build-push-action@v5
      with:
        context: ./auth-gateway # Specify the build context
        push: true
        tags: |
          ${{ steps.image_meta.outputs.full_image_name }}
          ghcr.io/${{ steps.image_meta.outputs.repo_owner_lower }}/${{ env.DOCKER_IMAGE_NAME }}:latest # Tag 'latest' as well
        cache-from: type=gha # Use GitHub Actions caching for layers
        cache-to: type=gha,mode=max

    # -----------------------------------------------------
    # QUALITY: Image Vulnerability Scanning (Critical for Production)
    # -----------------------------------------------------
    - name: Run Trivy vulnerability scan
      uses: aquasecurity/trivy-action@master
      with:
        image-ref: ${{ steps.image_meta.outputs.full_image_name }}
        format: 'table'
        exit-code: '1' # Fail the build if critical or high vulnerabilities are found
        severity: 'CRITICAL,HIGH'
        
  # -----------------------------------------------------
  # Job 2: Deploy to Remote Host
  # -----------------------------------------------------
  deploy:
    runs-on: ubuntu-latest
    needs: build # Must wait for the build job to complete
    
    steps:
    # -----------------------------------------------------
    # SECURITY: Use the dedicated SSH Action (avoid writing key to disk)
    # RELIABILITY: Use a cleaner, single-command deployment
    # -----------------------------------------------------
    - name: Deploy to remote host via SSH
      uses: appleboy/ssh-action@v1.0.1
      with:
        host: ${{ env.REMOTE_HOST }}
        username: ${{ env.REMOTE_USER }}
        port: ${{ env.REMOTE_PORT }}
        key: ${{ secrets.DEV_SSH_KEY }}
        # The script executes on the remote host
        script: |
          # Define environment variables on the remote side
          FULL_IMAGE_NAME=${{ needs.build.outputs.image_tag }}
          DOCKER_IMAGE_NAME=${{ env.DOCKER_IMAGE_NAME }}
          ENV_FILE_PATH=${{ env.ENV_FILE_PATH }}
          PEM_FOLDER_PATH=${{ env.PEM_FOLDER_PATH }}

          echo "Attempting to deploy image: $FULL_IMAGE_NAME"
          
          # Pull the image directly from the registry
          docker pull $FULL_IMAGE_NAME

          # Stop and remove existing container if running
          docker stop $DOCKER_IMAGE_NAME || true
          docker rm $DOCKER_IMAGE_NAME || true
          
          # NOTE: Production environments should ideally use a proper orchestration tool
          # (Kubernetes/Helm) instead of raw docker run.
          
          # Run new container
          docker run -d \
              --name $DOCKER_IMAGE_NAME \
              --restart unless-stopped \
              -p 3030:3030 \
              --env-file $ENV_FILE_PATH \
              -v $PEM_FOLDER_PATH:/app/.pem \
              --mount type=bind,src=/etc/letsencrypt,dst=/etc/letsencrypt,ro \
              $FULL_IMAGE_NAME
          
          # Clean up old images
          docker image prune -f
          
          echo "auth-gateway deployment completed successfully"

    # -----------------------------------------------------
    # Verification Step
    # -----------------------------------------------------
    - name: Verify deployment
      uses: appleboy/ssh-action@v1.0.1
      with:
        host: ${{ env.REMOTE_HOST }}
        username: ${{ env.REMOTE_USER }}
        port: ${{ env.REMOTE_PORT }}
        key: ${{ secrets.DEV_SSH_KEY }}
        script: |
          docker ps | grep ${{ env.DOCKER_IMAGE_NAME }}
          if [ $? -eq 0 ]; then
            echo 'auth-gateway container is running successfully!'
          else
            echo 'Error: auth-gateway container is NOT running.'
            exit 1
          fi
